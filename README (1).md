[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/fiBtbQme)
# מבוא למדעי המחשב - תרגיל בית 2 - סמסטר א' 24-25

שם הסטודנט:

תעודת זהות:
## הנחיות
### הנחיות כלליות
- בתחילת העבודה יש לעדכן את שם הסטודנט ומספר תעודת הזהות בקובץ הנוכחי (readme.md) ולעדכן פרטים בקובץ ההצהרה (declaration.md).
- ודאו כי אתם מתמצאים באופן פעולת גיט (git) וגיטהאב (GitHub), ויודעים כיצד לבצע פעולת קומיט (commit) כדי לעדכן את הגיט המקומי ופעולת פוש (push) כדי לעדכן את גיטהאב. אין לעדכן קבצים ישירות דרך גיטהאב.
- **חובה** לעשות קומיט לאחר כל משימה וסעיף שסיימתם, **לפחות**.
- הרפוזיטורי (repository) בגיטהאב מכיל טסטים שבודקים את נכונות הפתרון. אנא עקבו אחר ההנחיות להרצת הטסטים למטה.
- טסטים נוספים שאינם מפורסמים מראש ירוצו לאחר מועד ההגשה.
- הקומיט שיבדק הוא הקומיט האחרון שבוצע לפני מועד ההגשה.

### הנחיות לתרגיל
- אלמנט עיקרי בתרגיל זה הוא פיתוח חשיבה אלגוריתמית ויישומה בהתאם לכלים שנלמדו. שימו לב לעקוב במדויק אחרי ההוראות והדוגמאות בכל משימה.
- בתרגיל בית זה ארבע משימות. יש לפתור את כולן.
- לכל משימה, יש ליצור קובץ נפרד בשם taskN.py. למשל, task3.py עבור משימה 3.
- יש לכתוב את שמות הפונקציות בדיוק בשם שהוגדר לכם.
- מומלץ לסיים את שתי המשימות הראשונות בשבוע הראשון ולהשאיר את שתי המשימות האחרונות לשבוע השני.
- הקפידו לכתוב קוד קריא - כזה שאם חבר יקרא, הוא יצליח להבין לבדו.

### הנחיות להרצת טסטים
למטלה זו מצורף סקריפט בדיקה בשפת bash. את הסקריפט ניתן להריץ באופן הבא:

- בתוך vscode פתחו טרמינל חדש מסוג Git Bash. ניתן לעשות זאת ע"י פתיחת טרמינל כרגיל, ולאחר מכן לחיצה על חץ ליד סימן הפלוס בטרמינל, בצד ימין-למעלה, ולחיצה על Git Bash (או שורה אחרת עם שם דומה. ניתן לראות בתמונה למטה:
https://code.visualstudio.com/assets/docs/sourcecontrol/intro/git-bash.png
- ודאו שאתם נמצאים בתיקיית המטלה.
- הריצו באופן חד פעמי את הפקודה `chmod +x ./tester.sh`.
- מעכשיו, בכל פעם שתרצו להריץ את הטסטים פשוט הריצו `tester.sh/.`.
- לאחר שכל הטסטים עברו בהצלחה, עשו **push** לגיט ותוודאו שהטסטים עברו פעם נוספת - זוהי "תעודת הביטוח" שלכם.

---
## משימות 
### משימה 1
<details open>
<summary>לחץ לפרטים</summary>

בתרגיל זה נבנה מחשבון פשוט התומך בפעולות חיבור וחיסור, ובסוגריים. יש לכתוב שתי פונקציות:
1. פונקציה `check_valid(expression)`: מקבלת ביטוי מתמטי `expression` מהמשתמש ובודקת האם הוא תקין. ביטוי תקין אינו יכול להיות ריק, ויכול להכיל רק:
- חיבור וחיסור
- סוגריים עגולים
- מספרים שלמים

בנוסף,

- אם הביטוי אינו תקין , יש לדרוש מהמשתמש להזין ביטוי תקין
- אם הביטוי מכיל רווחים הוא נחשב תקין, אבל יש למחוק את הרווחים מהביטוי

1. פונקציה `evaluate(expression)`: מקבלת ביטוי תקין ומחשבת אותו *רקורסיבית*

יש לכתוב תוכנית הקולטת ביטוי חשבוני, ומשתמשת בשתי הפונקציות הנ"ל כדי לחשב את ערכו, לבסוף מדפיסה אותו.

**הנחיות**:
- הפתרון חייב להיות *רקורסיבי* במהותו. נסיונות לעקוף את הדרישה לפתרון רקורסיבי לא ינוקדו. דוגמא לנסיון כזה היא שימוש בפונקציה רקורסיבית שלא עושה דבר, ואז לקרוא לפונקציה שאינה רקורסיבית שפותרת את הבעיה.
- ניתן לממש פונקציה רקורסיבית שתיקרא ע"י `evaluate`.
- יש לבדוק תקינות קלט.
- ניתן להניח כי לא יוזנו מספרים עשרוניים.
- ניתן לממש פונקציות עזר נוספות לפי הצורך.

**דוגמאות ריצה:**
```
Enter your mathematical expression: 9+8+3-(8+1
Expression is not valid! Please try again: 1 - (4-3) + 3
1-(4-3)+3 = 3
```
```
(2+3)-(4+7)-(3-5)-(9-6)-(10-2) # valid and equals -15
6+10-(2+4                      # not valid
7-9                            # valid and equals -2
(6+3)-6-9+7-7                  # valid and equals -6
```
</details open>

### משימה 2
<details>
<summary>לחץ לפרטים</summary>

קבוצת סטודנטים החליטה שבמקום לשחק במשחקים, הם יכתבו תכנה שתשחק את המשחק באופן אוטומטי, וכך יוכלו להתפנות לדברים אחרים. המשחק מזכיר *אן דן דינו* ומתבצע כך:

**תחילת המשחק:**  
- המשתתפים עומדים במעגל, כאשר מוגדר משתתף שנחשב ראשון.  
- מוגדר מספר **(steps)**.

**מהלך המשחק**
- מתחילים מהמשתתף הראשון.
- בכל סבב סופרים משתתפים בכיוון השעון (ראשון, שני, שלישי, וכך הלאה)
- כאשר מגיעים למספר **(steps)**, המשתתף אליו הגענו יוצא מהמשחק.
- בסבב הבא מתחילים לספור שוב מהשחקן הבא אחרי זה שיצא.
- המשחק נגמר כאשר נשאר משתתף יחיד, והוא מוגר כמנצח.

כתבו פונקציה `play_game` שמקבלת רשימה של השחקנים וכמות צעדים **steps**.
הפונקציה מחזירה שני פרמטרים: רשימה של השחקנים, לפי סדר הוצאתם ושם השחקן המנצח.

**הנחיות:** 
- יש להזין את השמות ביחד עם steps כפרמטר לתוכנית (steps תמיד יהיה הפרמטר האחרון).
- ניתן להניח כי כל השמות חוקיים.
- ניתן להניח כי steps הוא מספר שלם.
- במידה והוזן steps שאינו חיובי ממש יש להדפיס הודעת שגיאה ולצאת מהתוכנית.
- במידה והוזנו פחות מ-2 שחקנים יש להדפיס הודעת שגיאה ולצאת מהתוכנית

**דוגמאות ריצה:**

עבור השמות `["Alice", "Bob", "Charlie", "Dana"]` ו-steps=6:
```
python task2.py Alice Bob Charlie Dana 6
Eliminated order: ['Bob', 'Alice', 'Dana']
Winner: Charlie
```
הסבר: 
- אליס היא השחקנית הראשונה. כשאנחנו סופרים 6 צעדים עם כיוון השעון (ימינה) נגיע לבוב.
- נשארנו עם אליס, צ'רלי ודנה. כשאנחנו סופרים 6 צעדים מצ'רלי מגיעים לאליס.
- נשארנו עם צ'רלי ודנה. כשאנחנו סופרים 6 צעדים מצ'רלי מגיעים לדנה. לכן - צ'רלי הוא המנצח.


עבור השמות `["Alice", "Bob", "Charlie", "Dana", "Eli"]` ו-steps=3:
```
python task2.py Alice Bob Charlie Dana Eli 3
Eliminated order: ['Charlie', 'Alice', 'Eli', 'Bob']
Winner: Dana
```

הסבר: 
- אליס היא השחקנית הראשונה. כשאנחנו סופרים 3 צעדים עם כיוון השעון (ימינה) נגיע לצ'רלי.
- נשארנו עם אליס, בוב, דנה ואלי. כשאנחנו סופרים 3 צעדים מדנה מגיעים לאליס.
- נשארנו עם בוב, דנה ואלי. כשאנחנו סופרים 3 צעדים מבוב מגיעים לאלי.
- נשארנו עם בוב ודנה. כשאנחנו סופרים 3 צעדים מדנה מגיעים לבוב. לכן - דנה היא המנצחת.
  
עבור השמות `["Alice", "Bob"]` ו-steps=0:
```
python task2.py Alice Bob 0
Error: Invalid steps number.
```
עבור השמות `[Alice"]` ו-steps=2:
```
python task2.py Alice 2
Error: Too few players
```
---
</details open>

### משימה 3

<details>
<summary>לחץ לפרטים</summary>

אליס ובוב רוצים להתכתב בצורה **מאובטחת** באינטרנט כך שאף אחד לא יוכל להבין את ההודעות שלהם גם אם יצליח ליירט אותן. הם משתמשים בשיטת הצפנה שנקראת **RSA**, אחת משיטות ההצפנה הנפוצות בעולם.  

### שלבי האלגוריתם

#### 1. **יצירת מפתחות:**
- בוחרים **שני מספרים ראשוניים _שונים_ p ו-q**.  
- מחשבים את **λ**:
$\lambda = \text{lcm}(p-1, q-1)$.
  ה-**lcm** הוא המכנה המשותף המינימלי של q-1, p-1.
- בוחרים מספר _ראשוני_ **e** כך שהוא **לא** מחלק את **λ** (מספר זה נקרא "המפתח הציבורי").  
- מוצאים מספר **d** כך ש: $(c\cdot d) \\% \lambda = 1$ (מספר זה נקרא "המפתח הפרטי").


#### 2. **הצפנה של הודעה (מספר):**  
אם ההודעה היא m, אז ניצור את ההודעה המוצפנת $c$ על ידי $c = m^e \% n$, כאשר $n=p\cdot q$.


#### 3. **פענוח של הודעה (מספר שלם):**  
אם ההודעה המצופנת היא $c$, אז נשחזר את $m$ על ידי $m = c^d \% n$.

#### 4. **הצפנת טקסט:**  
כדי להצפין טקסט כמו "HELLO":
- כל תו מומר לערך ה-**ASCII** שלו (למשל, 65='A').  
- כל תו מוצפן בנפרד לפי השלבים הקודמים.  
- יש לחבר את כל הערכים על ידי הוספת תו ב- `$`.  
- דוגמה: 'AB' יכול להיראות לאחר הצפנה ושרשור כך- `156$104`.

### **המשימה**  
כתבו תוכנית היוצרת מפתחות הצפנה חדשים (e, d, n).
לאחר מכן, מציעה למשתמש מספר אפשרויות:
1. **הצפנת הודעה** [בעזרת המפתח הציבורי (e, n)].  
2. **פענוח הודעה** [בעזרת המפתח הפרטי (d, n)].
3. **יצירת מפתחות חדשים**.
4. **יציאה**.


### **הנחיות:**
#### ארגון הקוד
  - במודול `random_util.py` נתונה פונקציה שמחזירה מספר ראשוני.
  - יש לממש את כל הפונקציות שקשורות בהצפנה, פענוח ויצירת מפתחות במודול נפרד בשם `rsa.py`.
  - את התוכנית הראשית יש לממש בקובץ המשימה, `task3.py`. המפתחות $e,d,n$ נוצרים אוטומטית בתחילת התוכנית. 
  - התחילו מתבנית הקוד הבאה:
```
if __name__ == "__main__":
    e, d, n = # Get keys somehow
    program(e, d, n)
```

#### תקינות הקלט
  - יש לבדוק את תקינות הקלט של הבחירה, אך ניתן להניח כי יוזן מספר שלם.
  - יש ליצור את המפתחות בצורה חוקית לפי ההגדרות בתחילת השאלה (לא ייתכן שהתהליך ייכשל, אך ייתכן שיהיה צורך בכמה נסיונות).
  
#### הנחיות נוספות
  - בגלל שמדובר בחישובים שעשויים להיות איטיים, ריצת התוכנית עשויה לקחת קצת זמן.
  - אין להשתמש בפונקציית `pow` או באופרטור ** (יכול לגרום ל-overflow).



#### דוגמאות ריצה:
הערכים `p,q` שהוגרלו הם כאלה כך ש-`n=37347979, e=8573, d=2961237`.
```
Welcome to our encryption app!
Here are your available options:
1. Encrypt a new message
2. Generate new keys
3. Exit
Please choose an action: 1
Enter your message: Hello
Encrypted message is `24550831$17848346$21349315$21349315$25525994`
------------------------
Here are your available options:
1. Encrypt a new message
2. Decrypt the current message
3. Generate new keys
4. Exit
Please choose an action: 5
Illegal input! Please choose an action: 2
Decrypted message is `Hello`
------------------------
Here are your available options:
1. Encrypt a new message
2. Generate new keys
3. Exit
Please choose an action: 3
```
הערכים `p,q` שהוגרלו הם כאלה כך ש-`n=84339587, e=2621, d=18112421`.
```
Welcome to our encryption app!
Here are your available options:
1. Encrypt a new message
2. Generate new keys
3. Exit
Please choose an action: 1
Enter your message: Hi!
Encrypted message is `67336366$36865766$45920903`
------------------------
Here are your available options:
1. Encrypt a new message
2. Decrypt the current message
3. Generate new keys
4. Exit
Please choose an action: 3
------------------------
Here are your available options:
1. Encrypt a new message
2. Generate new keys
3. Exit
Please choose an action: 1
Enter your message: Hi!
Encrypted message is `49247354$4824352$50855469`
------------------------
Here are your available options:
1. Encrypt a new message
2. Decrypt the current message
3. Generate new keys
4. Exit
Please choose an action: 4
```
</details>



### משימה 4

<details open>
<summary>לחץ לפרטים</summary>

סדרת טריבונצ'י היא סדרה רקורסיבית המוגדרת באופן הבא

```
F(n) = F(n-1) + F(n-2) + F(n-3)
```
כאשר,
```
F(0) = 0, F(1) = 1, F(2) = 1
```
יש לכתוב שתי פוקציות:
1. הפונקציה `tribonacci_recursive(n)`: תקבל מספר שלם `n` ותחשב את האיבר ה-n בסדרה באופן רקורסיבי.
2. הפונקציה `tribonacci_iterative(n)`: תקבל מספר `n` ותחשב את האיבר ה-n בסדרת באופן איטרטיבי (עם לולאה).

כדאי להסתמך על הגישות שהוצגו בהרצאה לשני המקרים, עבור סדרת פיבונצ'י.
בנוסף, יש לכתוב פונקציה `run_and_time(n)` אשר תריץ את שתי הפונקציות ותדפיס את זמן הריצה של כל אחת. כדי למדוד את זמן הריצה של פונקציה, ניתן להעזר בתבנית הקוד הבאה:

```
import time

def my_function():
    # your code here
    
start_time = time.time()
my_function()
end_time = time.time()
execution_time = end_time - start_time
print(f"Execution time: {execution_time} seconds")
```
#### דוגמאות ריצה:
בקריאה ל `run_and_time(10)` הפלט יהיה:
```
Iterative Execution time: ## seconds
F(10) = 149
Recurise Execution time: ## seconds
F(10) = 149
```
כאשר זמן הריצה צונזר, אך בפועל יודפס מספר עשרוני כלשהו.

</details>
